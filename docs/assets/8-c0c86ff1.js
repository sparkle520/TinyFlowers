const n="# IoC (inversion of control)  \r\n\r\n**IoC** (控制反转) 通过将控制权交给第三方来达到解耦.相当于手动挡变成了自动挡，而无需自己 `new` 对象.  \r\n\r\n对于**IoC**有两种实现方式，分别为依赖查找(DL)和依赖注入(DI).通常采用后者，也是**spring**的核心.\r\n\r\n## 依赖注入(Dependency injection)  \r\n\r\n在**spring**中，通过**IoC容器**，动态的将某个依赖关系注入到组件之中，减少对象之间的紧耦合性并提高可重用性.  \r\n\r\n# spring IoC 容器 \r\n\r\nSpring 提供了两种 IoC 容器，`BeanFactory` 和 `ApplicationContext`.\r\n\r\n## BeanFactory \r\n\r\n是最为基础的IoC容器，`BeanFactory` 就是一个管理 `Bean` 的工厂，它主要负责初始化各种  `Bean`，并调用它们的生命周期方法. \r\n\r\n## ApplicationContext  \r\n\r\n`ApplicationContext` 是 `BeanFactory` 的子接口，由 `BeanFactory` 派生而来，通常成为Spring上下文，具有 `BeanFactory` 的基本功能，同时拓展了功能.\r\n\r\n- 消息源 (MessageSource) ：用于实现国际化和消息查找\r\n- 资源加载 (ResourceLoader) ：可以从多种资源位置如文件系统、类路径加载资源\r\n- 事件传播 (ApplicationEventPublisher) ：支持发布和监听应用事件\r\n- 自动装配 (AutowiredAnnotationBeanPostProcessor) ：支持基于注解的自动装配\r\n\r\n## BeanFactory 和 ApplicationContext 区别  \r\n\r\n`beanFactory` 在初始化容器时，并未实例化 `Bean`，直到第一次访问某个`Bean` 时才实例化目标 `Bean`. 如果 `Bean` 的某一个属性没有注入，直至第一次调用 `getBean` 方法才会抛出异常. \r\n\r\n而 `ApplicationContext` 则在初始化应用上下文时就实例化所有单实例的 `Bean`.\r\n\r\n# sping IoC 容器注册 bean \r\n\r\nspring IoC 容器注册 bean 的方式有xml(不推荐)、`@Configuration` + `@Bean` (配置类方法) 、`@Component` 、 `@Controller` 、`@Service` 、 `@Repository` 、 `@Resource` 、`@Import`.\r\n# spring IoC 容器自动装配 bean \r\n\r\nspring IoC 容器自动装配 方式有 xml(不推荐)，注解(常用).  \r\n\r\n## 注解自动装配 bean  \r\n\r\n### @Resouce \r\n\r\n默认情况下 `@Resource` 按照 `name` 属性注入，如果没有显式声明则按照字段名或setter方法setXXX中XXX作为 bean name.  \r\n\r\n当 `@Resource` 不设置任何值时，`isDefaultName` 会为 `true`，当对应字段名称的 `bean` 或者`BeanDefinition` 已存在时会走 `byName` 的形式，否则走 `byType` 的形式；\r\n\r\n只指定了 `type` 属性时，只有当对应的名称不存在对应的 `bean` 或 `BeanDefinition`，才会通过 `byType` 找到唯一的一个类型匹配的 `bean`；\r\n\r\n只指定了 `name` 属性，会执行 `getBean` 方法，根据指定的 `name` 来获取 `bean`；\r\n\r\n既指定了 `name` 属性，又指定了 `type` 属性，会先根据 `name` 查找对应的 `bean`，然后进行 `type` 类型比较. \r\n\r\n### @Autowired \r\n\r\n`byType` 优先，`Qualifier` 其后，然后是 `byName`.";export{n as default};
